"""Module on conspect part 2 of the book CHISTYI COD."""

# **Модули и пакеты**

# Модуль (module) представляет собой программу Python, которая может импорти-
# роваться другими программами Python, чтобы те могли воспользоваться кодом
# модуля. Модули, входящие в поставку Python, образуют стандартную библиотеку
# Python.
# Например программу spam.py , другие программы смогут использовать, если выполнить команду import spam

# Пакет (package) представляет собой набор модулей. Чтобы создать его, следует
# разместить в папке файл с именем __init__.py . Пакеты могут содержать несколько модулей (то есть файлов .py ) или других
# пакетов (других папок, содержащих файлы __init__.py

# **Вызываемые объекты и первоклассные объекты**

# Любой объект, реализу-
# ющий оператор вызова — круглые скобки () , называется вызываемым объектом
# (callable).

# Классы относятся к концепциям ООП. Класс является примером вызываемого объ-
# екта, который не является функцией или методом.

# В Python функции являются первоклассными объектами (first-class objects). Это
# означает, что их можно сохранять в переменных, передавать в аргументах при
# вызове функций, возвращать при вызове функций и делать все остальное, что
# можно сделать с объектом.
# Первоклассные функции чаще всего используются для передачи функций другим
# функциям.
# * Таким образом создаются псевдонимы (aliases) — другие имена для существующих
# функций. Они часто используются в тех ситуациях, когда возникает необходимость
# в переименовании функции.

# ![image.png](attachment:image.png)

# **Команды и выражения**

# Выражениями (expressions) называются инструкции, состоящие из операторов и зна-
# чений, результатом вычисления которых является одно значение.

# Практически все остальные инструкции в Python являются командами (statements). Некоторые команды могут вклю-
# чать выражения.

# Функция print() в Python 3 имеет возвращаемоеЧастые ошибки при использовании терминов
# 153
# значение (которое всегда равно None ), может передаваться в аргументе другим
# функциям и может присваиваться переменным.

# ![image.png](attachment:image.png)

# **Блок, секция и тело**

# В официальной документации Python предпочтение отдается термину секция
# (clause) вместо «блок» (https://docs.python.org/3/reference/compound_stmts.html).
# Следующий код является секцией:

# Это допустимый, хотя и не рекомендуемый синтаксис Python:

# +
# if name == 'Zophie': print('Hello, kitty!')
# if name == 'Zophie': print('Hello, kitty!'); print('Do you want a treat?')
# -

# Однострочный синтаксис не может использоваться с другими командами, которым требуется новый блок

# ![image.png](attachment:image.png)

# **Переменные и атрибуты**

# Переменные (variables) — имена, ссылающиеся на объекты.

# Атрибутом (attribute) называется «любое имя, следующее за точкой». Атрибуты связываются с объектами (имя перед точкой).
# В других языках атрибуты называются полями (fields), свойствами (properties) или
# компонентными переменными (member variables).
# * sys.exit() функция exit() считается атрибутом объекта
# модуля sys

# **Функции и методы**

# * Функция (function) — совокупность кода, выполняемого при вызове.
# * Методом (method) называется функция (или вызываемый объект), связанная с классом.  К функциям относятся встроенные функции, те связанные с модулем.

# ![image.png](attachment:image.png)

# * len() — функция
# * upper() — метод строк. Методы также считаются
# атрибутами объектов, с которыми они связываются.
# * Функция sqrt() связывается с именем math , но это модуль, а не класс.
# Точка необязательно означает, что перед вами именно метод, а не функция.

# **Итерируемые объекты и итераторы**

# Итерируемые объекты (iterables) -используются в циклах for.
# * range(3) - возвращает объект диапазона
# * list('cat') -  возвращает объект списка.

# итерируемые объекты:
# * последовательностей (например, диапазоны, списки, кортежи и строки)
# * объектов-контейнеров (словари, множества и объекты файлов)

# Итератор способен перебрать все элементы итерируемого объекта только один раз,
# так же, как можно только один раз.Если потребуется снова перебрать итерируемый объект, необходимо
# снова вызвать iter() для создания другого итератора. итерируемые объекты передаются в аргументах функции iter() ,
# тогда как объект, возвращаемый вызовами iter() , является итератором. Объек-
# ты-итераторы передаются функции next() .

# При использовании цикла for итерируемые объекты передаются встроенной
# функции iter() , которая возвращает объекты-итераторы (iterators). И если
# итерируемый объект содержит элементы, итератор следит за тем, какой элемент
# будет использован в цикле следующим. При каждой итерации цикла объект-
# итератор передается встроенной функции next() для получения следующего
# элемента в итерируемом объекте.

# ![image.png](attachment:image.png)

# если вызвать next() после того, как был возвращен последний
# элемент в итерируемом объекте, Python выдает исключение StopIteration ❶ . Вме-
# сто того чтобы аварийно завершать программы с сообщением об ошибке, циклы for
# в Python перехватывают это исключение, чтобы знать, когда следует остановить
# перебор.

# **Параметры и аргументы**

# Параметры (parameters) — имена переменных, заключенные в круглые скобки
# в команде def . Аргументами (arguments) называются значения, передаваемые при
# вызове функции, которые затем присваиваются параметрам.

# ![image.png](attachment:image.png)

# В команде def имена name и species — параметры ❶ . В вызове функции 'Zophie' и 'cat' — аргументы ❷ .

# **Явные и неявные преобразования типов**

# Явные преобразования (int('42')) правильнее на-
# зывать приведением типа (casting), хотя программисты все равно часто называют этот процесс преобразованием (converting) объекта.

# Python часто выполняет неявные преобразования типов (coercion) — например,
# когда вычисление выражения 2 + 3.0 дает результат 5.0

# **Свойства и атрибуты**

# Во многих языках термины «свойство» (property) и «атрибут» (attribute) используются как синонимы, но в Python эти слова имеют разный смысл

# **Байт-код и машинный код**

# Исходный код компилируется в так называемый машинный код (machine code) —
# инструкции, которые могут непосредственно выполняться процессором. Машинный код состоит из инструкций из встроенного набора команд (instruction
# set) процессора. Откомпилированная программа, состоящая из машинного кода, называется двоичным файлом (binary). Для таких уважаемых языков, как C, существуют специальные программы — компиляторы; они преобразуют исходный
# файл с кодом C в двоичные файлы почти для любых существующих процессором.

# Вместо машинного кода, который выполняется не-
# посредственно процессором, можно создать байт-код (bytecode). Байт-код, также
# называемый портируемым (portable) кодом, или p-кодом, выполняется не напрямую
# процессором, а специальной программой — интерпретатором.

# Байт-код Python сохраняется в файлах .pyc , которые иногда встречаются среди
# исходных файлов .py . Интерпретатор CPython, написанный на C, может компили-
# ровать исходный код Python в байт-код Python, а затем выполнять эти инструкции.

# **Библиотеки, фреймворки, SDK, ядра и API**

# Библиотека (library) — общий термин для подборки кодов, написанных третьей
# стороной. Библиотека может содержать функции, классы или другие фрагменты
# кода, предназначенные для использования разработчиками. Библиотека Python
# может быть реализована в виде пакета, набора пакетов и даже отдельного модуля.

# Стандартная библиотека (например,
# стандартная библиотека Python) представляет собой программную библиотеку,
# которая должна быть доступна для всех реализаций языка программирования.

# Фреймворком (framework) называется подборка кода, работающая по принципу
# инверсии управления; разработчик пишет функции, которые вызываются фрейм-
# ворком по мере надобности (вместо вызова функций фреймворка из кода разработ-
# чика). Инверсия управления часто описывается фразой «не звоните нам, мы сами
# вам позвоним».

# Ядро, или движок (engine), — крупная автономная система, которой могут управ-
# лять внешние программы разработчика. Разработчики обычно вызывают функции
# ядра для выполнения больших сложных задач. Примеры — игровые и физические
# движки, рекомендательные системы, ядра баз данных, ядра для шахматной игры
# и поисковые системы

# Интерфейс прикладного программирования, или API (Application Programming
# Interface), — интерфейс для работы с библиотекой, SDK, фреймворком или ядром,
# предназначенный для внешнего использования. API указывает, как вызывать
# функции или обращаться с запросами к библиотеке для получения доступа к ее
# ресурсам. Создатели библиотеки (обычно) публикуют документацию API. Многие
# популярные социальные сети и веб-сайты предоставляют HTTP API, для того чтобы
# их услугами могли пользоваться программы (а не только люди с веб-браузерами).
# Используя такие API, можно писать программы, которые, например, автоматически
# публикуют сообщения в Facebook или читают потоки сообщений Twitter.

# **Не копируйте изменяемые значения
# без copy.copy() и copy.deepcopy()**

# Одна из распространен-
# ных ошибок: разработчик копирует одну переменную, ссылающуюся на изменяемый
# объект, в другую переменную и думает, что копируется реальный объект. В Python
# команды копирования никогда не копируют объекты; они копируют только ссылки на объект. обе переменные ссылаются на один и тот же объект списка.

# Одно из возможных решений
# этой проблемы заключается в копировании объекта списка (а не только ссылки)
# функцией copy.copy()

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# Хотя bacon и ham — два разных объекта списков, они ссылаются на одни и те же внутренние списки [1, 2] и [3, 4] , так что изменения в этих внутренних списках будут отражены
# в обеих переменных, несмотря на использование copy.copy() . Проблема решается использованием функции copy.deepcopy() , которая копирует все объекты списков внутри копируемых объектов списков.

# ![image.png](attachment:image.png)

# И хотя функция copy.deepcopy() работает чуть медленнее copy.copy() , она без-
# опаснее, если вы не знаете, содержит ли копируемый список другие списки (или
# другие изменяемые объекты, такие как словари или множества). В общем слу-
# чае я рекомендую всегда использовать функцию copy.deepcopy()

# **sort()**

# Метод sort() исполь-
# зует ASCII-алфавитную сортировку (обобщенный термин, означающий сортировку
# по кодовым пунктам) вместо алфавитной сортировки.

# Чтобы получить кодовый пункт символа, передайте этот символ функции ord() .
# Также можно выполнить обратную операцию: передать кодовый пункт функции chr() , которая возвращает строковое представление символа.

# ![image.png](attachment:image.png)

# Если вы хотите выполнить сортировку по алфавиту, передайте метод str.lower
# в параметре key . Список сортируется так, как если бы для значений вызывался
# метод строк lower() :

# Обратите внимание: реальные строки в списке не преобразуются к нижнему регистру; они только сортируются так, как если бы они к нему были преобразованы

# ![image.png](attachment:image.png)

# **Не рассчитывайте на идеальную точность чисел
# с плавающей точкой**

# Компьютеры позволяют хранить только цифры двоичной системы счисления,
# то есть 1 и 0. Преобразование чисел идет в соответствии со стандартом IEEE 75. представление
# чисел с плавающей точкой в стандарте IEEE 754 не всегда точно соответствует
# исходному десятичному числу. Классический пример — число 0.1

# ![image.png](attachment:image.png)

# результат ошибки
# округления, возникающей из-за особенностей компьютерного представления
# и обработки чисел с плавающей точкой.

# Стандарт IEEE 754 (по техническим причинам объяснение которых выходит за
# рамки книги) также не позволяет представлять числовые значения, превышающие
# 2 53 . Например, числа 2 53 и 2 53 +1 в представлении с плавающей точкой округляются
# до 9007199254740992.0 :

# ![image.png](attachment:image.png)

# если вам требуется абсолютная точность (допустим, для научных или финан-
# совых вычислений), используйте встроенный модуль Python decimal , опублико-
# ванный по адресу https://docs.python.org/3/library/decimal.html. И хотя объекты
# Decimal работают медленнее, они обеспечивают более точную замену для значений
# с плавающей точкой. Например, вызов decimal.Decimal('0.1') создает объект,
# представляющий точное число 0.1 без погрешности, которая бы неизбежно при-
# сутствовала в значении с плавающей точкой 0.1 .

# объекты Decimal имеют прогнозируемый, четко установленный уровень точности.

# Вместо этого decimal.Decimal() следует передавать строковое пред-
# ставление числа с плавающей точкой

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# Чтобы узнать, сколько значащих цифр использует модуль decimal , обратитесь к атрибуту decimal.getcontext().prec

# ![image.png](attachment:image.png)

# **Не объединяйте операторы != в цепочку**

# оператор проверки неравенства != в цепочках использовать не стоит.

# ![image.png](attachment:image.png)

# a и c могут быть равны и выражение a != b != c все равно будет равно True :

# ![image.png](attachment:image.png)

# **Не забудьте запятую в кортежах
# из одного элемента**

# ![image.png](attachment:image.png)

# # Экзатически странности

# **Почему 256 — это 256, а 257 — не 257**

# При создании объекта
# нового целого числа в памяти CPython сначала проверяет, принадлежит ли оно
# диапазону от –5 до 256. В таком случае CPython экономит время, просто воз-
# вращая существующий объект целого числа, вместо того чтобы создавать его
# заново. Такое поведение также экономит память, так как она не расходуется на
# хранение малых целых чисел

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# Оператор == проверяет, равны ли два объекта, а оператор is проверяет их на тож-
# дественность, то есть сравнивает их идентичности.

# ![image.png](attachment:image.png)

# Python
# (интерпретатор Python, доступный для загрузки по адресу https://python.org)
# применяет крошечную оптимизацию, создавая объекты целых чисел от –5 до
# 256 при запуске каждой программы. создавая объекты целых чисел от –5 до
# 256 при запуске каждой программы. Эти числа называются предварительно
# определенными (preallocated), и CPython автоматически создает для них объекты,
# потому что они довольно часто применяются

# ![image.png](attachment:image.png)

# **Интернирование строк(string interning https://en.wikipedia.org/wiki/String_interning.)**

spam_4 = "cat"
eggs_4 = "cat"
print(spam_4 is eggs_4)
print(id(spam_4), id(eggs_4))

# Python замечает, что строковый литерал 'cat' , присвоенный eggs , совпадает со
# строковым литералом 'cat' , присвоенным spam ; таким образом, вместо второго,
# избыточного объекта string переменной eggs просто присваивается ссылка на
# тот же объект строки, который используется spam . Этим объясняется совпадение
# идентичностей строк

# Фиктивные операторы инкремента и декремента
# в языке Python

# В Python можно увеличить значение переменной на 1 или уменьшить его на 1 при
# помощи расширенных операторов присваивания. Выражения spam += 1 и spam -= 1
# увеличивают и уменьшают числовые значения в spam на 1 соответственно. В других языках, таких как C++ и JavaScript, существуют операторы ++ и -- для
# выполнения инкремента и декремента.

# операторы ++ и -- в Python не уве-
# личивают и не уменьшают значение, хранимое в переменной spam . Начальный
# знак - является унарным оператором отрицания Python.

spam_5: int = 42
print(-spam_5)  # "-"
print(-(-spam_5))  # -(-42)=42 отрицание отрицания
print(+spam_5)  # создает число с таким же знаком

# ![image.png](attachment:image.png)

# **all()**

# all() может использоваться в сочетании со списковыми включениями,
# для того чтобы сначала создать список логических значений на основании другого
# списка, а затем вычислить их сводное значение.

# ![image.png](attachment:image.png)

# **Логические значения как целые числа**

# логические значения True и False считаются эквивалентными
# 1 и 0 соответственно. В Python тип данных bool является субклассом типа данных
# int

print(isinstance(True, bool))
print(isinstance(False, int))

# ![image.png](attachment:image.png)

# Все приведенные примеры очень плохо читаются и никогда
# не должны использоваться в реальном коде. True и False стали ключевыми словами только в Python 3. А следовательно, в Python 2 True и False можно было использовать как имена переменных,
# что приводит к появлению парадоксального кода следующего вида

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# **Антигравитация в Python**

# >>>import antigravity
# Эта строка — забавная пасхалка, которая открывает в браузере классический комикс
# XKCD о Python (https://xkcd.com/353/). Вас может удивить, что Python открывает
# ваш браузер, но это встроенная возможность, предоставляемая модулем webbrowser .
# Модуль Python webbrowser содержит функцию open() , которая находит браузер по
# умолчанию вашей операционной системы и открывает его окно с заданным URL-
# адресом. Введите следующую команду в интерактивной оболочке:
# >>> import webbrowser
# >>> webbrowser.open('https://xkcd.com/353/')

# Имена функций подчиняются тем же правилам, что и имена идентификаторов во-
# обще (см. главу 4). Но обычно имена функций должны включать глагол, потому
# что функции выполняют некоторое действие. акже можно включить существи-
# тельное для описания объекта, с которым это действие выполняется. Например,
# имена refreshConnection() , setPassword() и extract_version() хорошо поясняют,
# что делает функция и к чему применяется действие.

# **Использование * и ** для передачи аргументов функции**
#

# Пзиционные аргументы (positional arguments) -  их
# позиция в вызове функции определяет, какой аргумент должен быть присвоен тому
# или иному параметру.

# ![image.png](attachment:image.png)

# * Синтаксис * позволяет передать функции элементы списка по отдельности, сколько
# бы элементов ни содержал список
# * Ключевому аргументу можно присвоить другое значение командой присваивания
# или синтаксисом **. Синтаксис ** позволяет создать специализированный словарь с настройками конфигурации, которые должны передаваться при вызове функции.

# ![image.png](attachment:image.png)

# **Использование * при создании вариадических функций**

# Вариадические функции — это функции, которые могут принимать переменное количество аргументов. Они позволяют создавать функции, которые могут обрабатывать нефиксированное количество входных параметров.

# В Python для создания вариадической функции используется символ * перед именем параметра. Это позволяет функции принимать любое количество позиционных аргументов. Если нужно также принимать именованные аргументы, используется **.
#

# Синтаксис ** показывает, что параметр kwargs может использоваться для всех
# аргументов «ключ — значение», переданных при вызове функции. Они будут храниться в виде пар «ключ — значение» в словаре.

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# **Использование * и ** для создания функций-оберток**

# # Функциональное программирование

# Функциональное программирование — это  парадигма программирования, уделяющая
# особое внимание написанию функций, которые выполняют вычисления без из-
# менения глобальных переменных или какого-либо внешнего состояния (файлов
# на жестком диске, подключений к интернету или баз данных)

# Побочные эффекты  - любые изменения, вносимые функцией в части программы, существующие за рамками ее собственного кода и локальных перемен-
# ных.

# В коде ниже побочных эффектов нет. тк она не влияет в программе ни на что за пределами ее кода.

# ![image.png](attachment:image.png)

# Функция addToTotal() имеет побочный эффект, потому что она изменяет элемент,
# существующий за пределами функции, — глобальную переменную TOTAL .

# К побочным эффектам также можно отнести модификацию на месте изменяемых
# объектов, ссылки на которые существуют за пределами функции. Например,
# следующая функция removeLastCatFromList() изменяет последний аргумент
# на месте:
#

# ![image.png](attachment:image.png)

# В этом примере переменная myPets и параметр petSpecies содержат ссылки на
# один и тот же список. Любые изменения на месте, вносимые в объект списка вну-
# три функции, также будут существовать за пределами функции, вследствие чего
# изменение становится побочным эффектом.

# Детерминированная функция (deterministic function) - которая для одного набора аргументов всегда возвращает
# одно и то же значение. Встроенная функция Python round() всегда возвращает 3 , если передать ей аргу-
# мент 3.14 .

# Недетерминированная функция (nondeterministic function) не всегда
# возвращает одно и то же значение при передаче одного набора аргументов. Напри-
# мер, вызов random.randint(1, 10) возвращает случайное целое число от 1 до 10.
# Функция time.time() не получает аргументов, но возвращает разные значени

# Кэширование: Это техника оптимизации, которая сохраняет результаты вычислений для повторного использования. Когда функция вызывается с определенными аргументами, результат этого вызова может быть сохранен (кэширован). При следующем вызове функции с теми же аргументами результат может быть взят из кэша, а не вычисляться заново.

# Преимущества кэширования для детерминированных функций:
#
# • Ускорение выполнения: Если функция выполняет сложные вычисления, кэширование позволяет избежать повторных вычислений, что значительно ускоряет выполнение программы.
#
#
# • Снижение нагрузки на ресурсы: Кэширование уменьшает количество ресурсов, необходимых для выполнения функции, так как не нужно повторно проводить те же самые вычисления.
#
# • Простота реализации: Для детерминированных функций кэширование легко реализовать, так как результаты всегда предсказуемы и не зависят от внешних факторов.

# Одно из преимуществ детерминированных функций — возможность кэширования
# их значений.

# *Чистая функция* = это Детерминированная функция, свободная от побочных эффектов. Их +-ы:
#
# *  подходят для модульного тестирования, потому что не требуют подготовки внешних ресурсов.
# * проще воспроизводятся ошибки, для чего достаточно
# вызвать функцию с теми же аргументами.
# * могут вызывать другие чистые функции, оставаясь чистыми.
# * В многопоточных программах чистые функции являются потоково-безопасными и могут выполняться параллельно. (Тема многопоточности выходит
# за рамки книги.)
# * Множественные вызовы чистых функций способны выполняться на параллельных ядрах процессора или в многопоточной программе, потому что они не зависят от внешних ресурсов, требующих их выполнения в определенной
# последовательности.

# На языке Python можно и нужно писать чистые функции там, где это возможно.

# **Функции высшего порядка**

# *Функции высшего порядка (higher-order functions)* могут получать другие функции в аргументах или использовать функции как возвращаемые значения.

# ![image.png](attachment:image.png)

# Функция callItTwice() работает с любой передаваемой функцией. В Python функции являются первоклассными объектами *(first-class objects)*; это означает, что они
# ничем не отличаются от других объектов: функции можно сохранять в переменных,
# передавать в аргументах или использовать как возвращаемые значения.

# **Лямбда-функции**

# Лямбда-функции (lambda functions), также называемые анонимными (anonymous)
# или безымянными (nameless) функциями, представляют собой упрощенные функ-
# ции, у которых нет имен, а код состоит из одной команды return . Лямбда-функции
# часто используются для передачи функций как аргументов других функций.

# Так как
# функции являются первоклассными объектами, лямбда-функцию можно присвоить
# переменной, фактически повторяя то, что делает команда def

# В реальном коде лучше использовать команды def, вместо того чтобы присваивать лямб-
# да-функции неизменяемым переменным. Лямбда-функции специально создавались для
# ситуаций, в которых функции не нуждаются в имени. Лямбда функции особенно полезны, когда необходимо передать небольшие функции в качестве аргументов в другие функции, такие как map, filter, или sorted.
#

# Допустим, у нас есть список чисел, и мы хотим получить только четные числа из этого списка:

# ![image.png](attachment:image.png)

# ** Объяснение:**
# 1. lambda x: x % 2 == 0: Это лямбда-функция, которая принимает один аргумент x и возвращает True, если x четное (остаток от деления на 2 равен 0), и False в противном случае.
# 2. filter: Функция filter принимает лямбда-функцию и итерацию (в данном случае numbers) и возвращает итератор, содержащий только те элементы, для которых результат лямбда-функции True.
# 3. list(...): Конвертируем результат в список, чтобы увидеть отфильтрованные четные числа.

# Пример 2: Использование лямбда-функции с map
#
# Ещё один распространённый способ использования лямбда-функций — это применение их с функцией map, чтобы преобразовать элементы из списка. Например, возьмем тот же список и умножим каждое число на 2:

# ![image.png](attachment:image.png)

# Объяснение:
# 1. lambda x: x * 2: Лямбда-функция, которая принимает число и умножает его на 2.
# 2. map: Функция map применяет лямбда-функцию ко всем элементам списка numbers и возвращает итератор с результатами.
# 3. list(...): Конвертируем результат в список.

# **Отображение и фильтрация со списковыми включениями**

# Отображение (map) и фильтрация (filter) — это два важных процесса, которые применяются к спискам в Python. Оба они могут быть элегантно реализованы с помощью списковых включений (list comprehensions), которые представляют собой краткий и лаконичный способ создания новых списков из существующих.
#
# **1. Отображение (Mapping)**
#
# Отображение — это процесс применения функции ко всем элементам последовательности (например, списка) с целью преобразовать эти элементы в новые значения.
#
# **Списковые включения для отображения**
#
# Предположим, у нас есть список чисел, и мы хотим создать новый список, где каждое число будет умножено на 2.

# Функция map() возвращает объект map , который можно получить в форме списка,
# для чего он передается функции list() . Отображенный список теперь содержит
# строковые значения на основании целых значений из исходного списка.

# ![image.png](attachment:image.png)

# * Объяснение:
# 1. [x * 2 for x in numbers]: Этот код создает новый список, перебирая все значения x из списка numbers и умножая каждое число на 2.
# * Результат: [2, 4, 6, 8, 10]

# * 2. Фильтрация (Filtering)*
# Фильтрация — это процесс удаления из последовательности элементов, которые не удовлетворяют определенному условию.
# * Списковые включения для фильтрации*
# Предположим, у нас есть тот же список чисел, и мы хотим создать новый список, который будет содержать только четные числа.
# * Функция filter() возвращает объект-фильтр, который можно снова передать
# функции list() .

# ![image.png](attachment:image.png)

# * Объяснение:
# 1. [x for x in numbers if x % 2 == 0]: Этот код создает новый список, перебирая все значения x из списка numbers и включая только те значения, которые являются четными (т.е. остаток от деления на 2 равен 0).
#
# * Результат:
# [2, 4, 6, 8, 10]

# *Комбинирование отображения и фильтрации*
#
# Вы также можете комбинировать отображение и фильтрацию в одном списковом включении. Например, предположим, что мы хотим получить квадрат четных чисел из списка:

# ![image.png](attachment:image.png)

# * *Объяснение:*
# 1. [x ** 2 for x in numbers if x % 2 == 0]: В этом списковом включении мы сначала фильтруем четные числа, а затем для каждого четного числа находим квадрат.
#
# * *Результат:*
#
# [4, 16, 36, 64, 100]

# Однако создание отображенных или отфильтрованных списков функциями map()
# и filter() в Python считается устаревшим. Вместо этого рекомендуется создавать
# их при помощи списковых включений. Списковые включения не только освобожда-
# ют вас от необходимости писать лямбда-функции, но и работают быстрее функций
# map() и filter() .

# ![image.png](attachment:image.png)

# **Возвращаемые значения всегда должны иметь
# один тип данных**

# Python является языком с динамической типизацией; это означает, что функции
# и методы Python способны возвращать значения любого типа данных. Но чтобы
# ваши функции были более предсказуемыми, вы должны стремиться к тому, чтобы
# они возвращали значения только одного типа данных.

# **Выдача исключений и возвращение
# кодов ошибок**

# ![image.png](attachment:image.png)

# Letters after x in
# after b in "Albert":', 'Albert'['Albert'.find('b') + 1:])
# "Albert": ert
# after x in "Albert":', 'Albert'['Albert'.find('x') + 1:])
# "Albert": Albert
# Часть кода 'Albert'.find('x') при вычислении возвращает код ошибки -1 .
# В результате выражение 'Albert'['Albert'.find('x') + 1:] преобразуется
# в 'Albert'[-1 + 1:] , что далее дает результат 'Albert'[0:] и, наконец, 'Albert' .
# Очевидно, это не то поведение, которое ожидалось от кода. При вызове index()
# вместо find() , как в 'Albert'['Albert'.index('x') + 1:] , возникло бы исключение.
# Проблема становится очевидной, и проигнорировать ее не удастся.

# # Комментарии, doc-строки и аннотации типов

# Комментарии, doc-строки и аннотации типов помогают поддерживать код в работоспособном состоянии.
# * комментарии лучше размещать в отдельной строке, а не в конце строки с кодом
# * Doc-строки представляют собой форму документирования функций, методов и модулей, специфическую для Python.
# Когда вы задаете комментарии в формате
# doc-строки, автоматизированные средства (такие как генераторы документации
# или встроенный модуль Python help() ) позволяют разработчикам легко найти
# информацию о вашем коде
# * Аннотации типов (type hints) представляют собой директивы, которые можно до-
# бавить в исходный код Python для указания типов данных переменных, параметров
# и возвращаемых значений. Это позволяет средствам статического анализа кода убедиться в том, что ваш код не сгенерирует исключений, обусловленных непра-
# вильными типами значений.

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# ![image.png](attachment:image.png)

# **Сводные комментарии**

# Программисты часто вставляют пустые строки, чтобы отделить
# «абзацы» кода друг от друга. Сводные комментарии обычно занимают одну строку
# в начале таких абзацев. В отличие от однострочных комментариев, поясняющих
# отдельные строки кода, сводные комментарии на более высоком уровне абстракции описывают, что делает код.

# ![image.png](attachment:image.png)

# **Кодовые метки и комментарии TODO**

# ![image.png](attachment:image.png)

# **Магические комментарии и кодировка исходных файлов**

# ![image.png](attachment:image.png)

# **Doc-строки**

# Doc-строки представляют собой многострочные комментарии, расположенные либо
# в начале файла .py с исходным кодом модуля, либо непосредственно после коман-
# ды class или def . Они содержат документацию об определяемом модуле, классе,
# функции или методе.
# Doc-строки должны быть оформлены в виде многострочных комментариев в тройных кавычках (вместо однострочных комментариев, начинающихся с решетки # ).
# Doc-строки всегда используют утроенные двойные кавычки вместо утроенных
# одинарных кавычек. вы можете прочитать doc-строки модуля, класса, функции или метода,
# проверяя атрибут __doc__ соответствующего объекта.
# doc-строка модуля должна быть первой
# строкой в модуле, она располагается после любых специальных комментариев —
# в частности, определения кодировки.
# Средства автоматизированного документирования могут пользоваться doc-
# строками для предоставления информации, соответствующей контексту. Одно из
# таких средств — встроенная функция Python help() — выводит doc-строку пере-
# данного ей объекта в более удобочитаемом формате, чем у необработанной строки
# __doc__ .

# ![image.png](attachment:image.png)

# Если doc-строка слишком велика, чтобы поместиться на экране, Python выводит
# подсказку -- More -- в нижней части окна. Нажмите ENTER, чтобы прокрутить
# текст к следующей строке, пробел для вывода следующей страницы или Q для
# прекращения просмотра doc-строки.

# **Аннотации типов**

# Аннотации типов в Python предоставляют необязательные средства статической
# типизации. Если вы используете аннотации типов, вам не нужно применять их к каждому зна-
# чению данных в программе. Вместо этого можно воспользоваться методом посте-
# пенной типизации, сочетающим гибкость динамической типизации с безо пасностью
# статической типизации: аннотации типов включаются только для некоторых пере-
# менных, параметров и возвращаемых значений.

# **Аннотации типов для набора типов**

# Переменные, параметры и возвращаемые значения Python могут принимать разные
# типы данных. Чтобы учесть эту возможность в программе, следует задать аннотации
# типов с несколькими типами; для этого надо импортировать Union из встроенного
# модуля typing . Набор допустимых типов задается в квадратных скобках после
# имени класса Union :

# ![image.png](attachment:image.png)

# Обратите внимание: лучше использовать форму команды импортирования from typing
# import X вместо import typing , а затем последовательно использовать развернутую
# форму typing. X для аннотаций типов во всей программе.

# ![image.png](attachment:image.png)

# *Обратное портирование аннотаций типов*

# даже если вы используете стиль аннотаций типов в ком-
# ментариях, все равно необходимо импортировать модуль typing ❶ , а также все
# псевдонимы типов, которые вы будете использовать в комментариях. В версиях
# до 3.5 стандартная библиотека не включала модуль typing , его следует установить
# отдельно следующей командой:
# python -m pip install --user typing

# # Измерение быстродействи анализ сложности алгоритмов

# **Модуль timeit**

# использовании алгоритма XOR, для того чтобы поменять
# местами два целых значения без использования третьей временной переменной:

# ![image.png](attachment:image.png)
